<p><strong>Router</strong></p>
<p>新しいスタイルの prefix を用いたURL生成は、まさしく 1.2 での admin ルーティングと同じく振舞います。同じ文法を使い、同じ方法で持続的になり、同じ方法で振る舞います。core.phpに<code>Configure::write('Routing.prefixes', array('admin',
'member'));</code>となっていると仮定します。prefix 無しのURLから次のようにすることができます：</p>
<pre>
$this->Html->link('Go', array('controller' => 'posts', 'action' => 'index', 'member' => true));
$this->Html->link('Go', array('controller' => 'posts', 'action' => 'index', 'admin' => true));
</pre>
<p>同様に、prefix 有りのURLにおいて、prefix 無しのURLに行きたい場合、次のようにします：</p>
<pre>
$this->Html->link('Go', array('controller' => 'posts', 'action' => 'index', 'member' => false));
$this->Html->link('Go', array('controller' => 'posts', 'action' => 'index', 'admin' => false));
</pre>

<p><strong>ルートクラス</strong></p>
<p>1.3 では、ルートが内部で再構築され、新しく<code>CakeRoute</code>クラスが作られました。このクラスは、このクラス独自のルートをパース・リバースマッチングすることを扱います。また、1.3 では独自のルートクラスを作成・使用することができるようになりました。アプリケーションのルートクラスで必要とされる特殊なルーティング機能を実装することができます。開発者のルートクラスは<code>CakeRoute</code>を継承しなければなりません。もしこれを継承しなければ、エラーが引き起こされます。一般的に、カスタムルートクラスがカスタマイズされた処理を提供するには、<code>CakeRoute</code>で見つけられる<code>parse()</code>メソッドと<code>match()</code>メソッドのどちらか（または両方共）をオーバーライドします。</p>

<p><strong>Dispatcher</strong></p>
<ul>
<li>フィルタされるアセットのパスに、アセットフィルタを定義しない状態でアクセスすると、404ステータスのレスポンスが吐き出されます。</li>
</ul>