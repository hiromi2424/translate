<h2>2.0でのビューの変更</h2>
<p>2.0では、密結合を減らし、開発者により強い力と柔軟性を提供するために、ビューの階層構造が少し変更されました。</p>
<h3>コールバックの位置の変更</h3>
<p>以前はbeforeLayoutは<code>scripts_for_layout</code>と<code>content_for_layout</code>が準備された後に起動されていました。2.0では、全ての特殊な変数が準備される前に<code>beforeLayout</code>が起動するようになり、レイアウトにそれらの変数が渡される前に操作することが可能になります。<code>beforeRender</code>もまた同様で、ビューでの変数全てが操作される前に起動するようになりました。これらの変更に加え、ヘルパーのコールバックはレンダリングするファイル名を常に受け取るようになりました。これはヘルパーが<code>$this-&gt;_View</code>を通してビューに、<code>$this-&gt;_View-&gt;content</code>を通してその時点でのビューのコンテンツにアクセスできることと併せて、以前より強い制御ができるようになります。</p>
<h3>ヘルパーのコールバックの特性の変更</h3>
<p>ヘルパーのコールバックは常に一つの引数、<code>beforeRender</code>と<code>afterRender</code>にはレンダリングされるビューファイルが、<code>beforeLayout</code>と<code>afterLayout</code>にはレンダリングされるレイアウトファイルが与えられるようになりました。ヘルパーの関数特性は以下のようにする必要があります。</p>
<pre>
<code>function beforeRender($viewFile) {

}

function afterRender($viewFile) {

}

function beforeLayout($layoutFile) {

}

function afterLayout($layoutFile) {

}</code>
</pre>
<h3>View::$output</h3>
<p>Viewは常に最後にレンダリングしたコンテンツ（ビューまたはレイアウト）を保持するようになりました。<code>$this-&gt;output</code>でアクセスできます。ヘルパーでは<code>$this-&gt;_View-&gt;output</code>とできます。このプロパティを更新すると、ビューのレンダリングの結果となるコンテンツを変更することになるでしょう。</p>
<h3>Cacheクラスを用いたエレメントのキャッシュ</h3>
<p>2.0でのエレメントのキャッシュは<code>Cache</code>クラスを用いて行われます。これは頻繁に使われるエレメントにAPCやMemcacheなどの速いキャッシュ機構を使うことを可能にします。デフォルトでは、Viewはエレメントのキャッシュを<code>default</code>設定に格納するでしょう。ビューファイルで<code>$this-&gt;elementCache</code>を設定することによってViewが使うデフォルトのキャッシュ設定を変えることができます。また、以前と同じようにエレメント毎のキャッシュ情報をセットすることができます。</p>
<pre>
<code>echo $this-&gt;element('side_menu', array('cache' =&gt; true));</code>
</pre>
<p>上記はエレメントのキャッシュを有効にし、ビューの<code>elementCache</code>設定に書き出すでしょう。</p>
<h4>エレメントに使われるキャッシュ設定を変更する</h4>
<p>cacheパラメーターのconfigという値を設定することによって、特定のキャッシュ設定にエレメントのキャッシュを書き出すことができます。</p>
<pre>
<code>echo $this-&gt;element('side_menu', array('cache' =&gt; array('config' =&gt; 'long_term')));</code>
</pre>
<p>上記は<code>long_term</code>キャッシュにおいて、キャッシュの書き出しとキャッシュされたエレメントの読み込みを行うことでしょう。以前のバージョンと違い、<code>element()</code>の呼び出しから直接エレメントのキャッシュの継続時間を操作することはできません。代わりにアプリケーションのbootstrap.phpに適切なキャッシュ設定を作成する必要があります。</p>
<h4>Creating custom storage keys</h4>
<p>As before you can use custom storage keys for element caching,
if the default ones don't work. By default, View uses the element
name, plugin, and passed param keys as the element cache key. If
this key doesn't give you the uniqueness you need, you can define a
custom key.</p>
<pre>
<code>echo $this-&gt;element('side_menu', array('cache' =&gt; array('key' =&gt; 'my_custom_key_value')));</code>
</pre>
<p>Custom key values are prefixed with <code>element_</code> before
being stored in <code>Cache</code>. This helps namespace them from
other content stored in the cache.</p>
<h3>CacheHelper decoupled</h3>
<p>In previous versions there was a tight coupling between
<code>CacheHelper</code> and <code>View</code>. For 2.0 this
coupling has been removed and <code>CacheHelper</code> just uses
callbacks like other helpers to generate full page caches.</p>
<h4>CacheHelper &lt;cake:nocache&gt; tags changed</h4>
<p>In previous versions, <code>CacheHelper</code> used a special
<code>&lt;cake:noncache&gt;</code> tag as markers for output that
should not be part of the full page cache. These tags were not part
of any XML schema, and were not possible to validate in HTML or XML
documents. For 2.0, these tags have been replaced with HTML/XML
comments.</p>
<ul>
<li><code>&lt;cake:noncache&gt;</code> becomes
<code>&lt;!--nocache--&gt;</code></li>
<li><code>&lt;/cake:nocache&gt;</code> becomes
<code>&lt;!--/nocache--&gt;</code></li>
</ul>
<p>The internal code for full page view caches has also changed, so
be sure to clear out view cache files when updating.</p>