<p>2.0では<code>Object::cakeError()</code>は削除されました。代わりに、これは数多くの例外に置き換えられました。以前はcakeErrorを呼んでいた全てのコアクラスは例外を投げるようになりました。これによりアプリケーションでエラーを処理するか組み込みの例外処理にそれを処理させるかを選ぶことができるようになります。</p>
<p>CakePHP2.0では今までよりコントロール性の高いエラーと例外処理があります。どのメソッドをデフォルトのエラーハンドラー、例外ハンドラーとするかを設定することができます。<br></p>
<h3>エラー設定</h3>
<pre>
<code>Configure::write('Error', array(
    'handler' =&gt; 'ErrorHandler::handleError',
    'level' =&gt; E_ALL &amp; ~E_DEPRECATED,
    'trace' =&gt; true
));</code>
</pre>
<p>エラーハンドラーを設定する際、以下の3つの組み込みのオプションがあります。</p>
<ul>
<li><code>handler</code> - callback - エラーを処理するためのコールバック。これに、匿名関数を含むどのような種類のコールバックも指定できます。</li>
<li><code>level</code> - int - 捕捉するエラーのレベル。エラーのレベルを選択するには、組み込みのPHPエラー定数とビットマスクを使ってください。</li>
<li><code>trace</code> - boolean - ログファイルにエラーのスタックトレースを含むか。エラー毎にスタックトレースがログに含まれることになります。これはいつ、どこでエラーが発生しているかを追跡するのに役に立ちます。</li>
</ul>
<p>エラーハンドラーはデフォルトで、<code>debug</code>が0より大きいときにエラーを表示し、debugが0のときエラーをログに記録します。両方のケースにおいて捕捉されるエラーの種類は、Error.levelで制御されます。</p>
<h4>独自のエラーハンドラーの作成</h4>
<p>コールバックの種類の範囲で、エラーハンドラーを作成することができます。例えば、エラーを処理するために<code>AppError</code>という名前のクラスを使うことができます。必要なことは以下の通りです。</p>
<pre>
<code>// app/config/core.php で
Configure::write('Error.handler', 'AppError::handleError');

// app/config/bootstrap.php で
App::import('Lib', 'AppError');

// app/libs/app_error.php で
&lt;?php
class AppError {
    public static function handleError($code, $description, $file = null, $line = null, $context = null) {
        echo 'エラーがありました！';
    }
}</code>
</pre>
<p>このクラス・メソッドはエラーが発生した時全てで「エラーがありました！」を出力します。全てのコールバックの種類でエラーハンドラーを定義できるようになったことから、PHP5.3以上を使っていれば匿名関数を使うことができるようになります。</p>
<pre>
<code>Configure::write('Error.handler', function($code, $description, $file = null, $line = null, $context = null) {
    echo 'なんてこった、なんか良くないことが起きちゃったよ';
});</code>
</pre>
<h3>例外（<em>Exception</em>）の設定</h3>
<pre>
<code>Configure::write('Exception', array(
    'handler' =&gt; 'ErrorHandler::handleException',
    'renderer' =&gt; 'ExceptionRenderer',
    'log' =&gt; true
));</code>
</pre>
<ul>
<li><code>handler</code> - callback - 例外を処理するためのコールバック。これを匿名関数を含む全てのコールバックの種類に設定できます。</li>
<li><code>renderer</code> - string - 捕捉されなかった例外をレンダリングする責任をもつクラス。もし独自のクラスを選択するなら、app/libsにそのクラスのファイルを設置するべきです。このクラスはrenderメソッドを実装する必要があります。</li>
<li><code>log</code> - boolean - trueの場合、例外とそのスタックフレームがCakeLogでログに記憶されます。</li>
</ul>
<p>デフォルトの例外レンダリングはHTMLページを表示します。設定を変更することにより、ハンドラー（<em>handler</em>）とレンダラー（<em>renderer</em>）のどちらかをカスタマイズすることができます。ハンドラーを変更することで、例外処理プロセス全般をコントロールすることができるようになり、一方レンダラーを変更することで、出力する種類・コンテンツ変更することと、またアプリケーション固有の例外処理を組み込むことが簡単にできるようになります。</p>
<h4>新しい例外クラス</h4>
<p>数多くの例外クラスがCakePHP2.0にはあります。それぞれの例外は以前の<code>cakeError()</code>のエラーメッセージの置き換えです。継承できることとロジックを含められることにより、例外は柔軟性を提供します。組み込みの例外処理は全ての捕捉されなかった例外を受け取り、役に立つページを書き出します。以前のとおり、プロダクション設定では捕捉されなかった例外は全て内部サーバーエラー（<em>Internal Server Error</em>）として扱われるでしょう。</p>
<h4>独自のアプリケーション例外を作る</h4>
<p>組み込みの<a href="http://php.net/manual/ja/spl.exceptions.php">SPL例外</a>、<code>Exception</code>そのもの、<code>CakeException</code>のどれかを使って独自のアプリケーション例外を作ることが出来ます。<code>CakeException</code>は、全ての<code>CakeException</code>オブジェクトが、自信の使うコードに拠って500または404エラーに強制されることにおいて特別です。開発モードでは<code>CakeException</code>オブジェクトは単純に、役に立つ情報を提供するためのクラス名にマッチする新しいテンプレートを必要とします。</p>
<pre>
class MissingWidgetException extends CakeException {};
</pre>
<p>上記のクラスは、<code>app/views/errors/missing_widget.ctp</code>を作ることによってナイスな開発用のエラーを提供することが出来ます。
The above class could provide nice development errors, by
creating <code>app/views/errors/missing_widget.ctp</code>. When in
production mode, the above error would be treated as a 500 error.
When subclassing <code>CakeException</code> the constructor has
been extended, allowing you to pass in hashes of data. These hashes
are passed into the template that is used to represent the error in
development mode, allowing you to create data rich exceptions. You
can also provide a message template which allows the native
<code>__toString()</code> methods to work as normal.</p>
<pre>
class MissingWidgetException extends CakeException {
    protected $_messageTemplate = 'Seems that %s is missing.';
}

throw new MissingWidgetException(array('widget' =&gt; 'Pointy'));
</pre>
<p>When caught by the built in exception handler, you would get a
<code>$widget</code> variable in your view template. In addition if
you cast the exception as a string or use its
<code>getMessage()</code> method you will get <code>Seems that
Pointy is missing.</code>. This allows you easily and quickly
create your own rich development errors, just like CakePHP uses
internally.</p>
<h4>Creating custom status codes</h4>
<p>You can create custom HTTP status codes by changing the code
used when creating an Exception.</p>
<pre>
throw new MissingWidgetHelperException('Its not here', 501);
</pre>
<p>Will create a 501 response code, you can use any HTTP status
code you want. If you have a code equal to or greater than 500 you
will see the error500 template. For any other error code you'll get
the error400 template.</p>
<h3>Extending and implementing your own Exception handlers</h3>
<p>You can implement application specific exception handling in one
of a few ways. Each approach gives you different amounts of control
over the exception handling process.</p>
<ul>
<li>Set Configure::write('Exception.handler',
'YourClass::yourMethod');</li>
<li>Create AppController::appError();</li>
<li>Set Configure::write('Exception.renderer', 'YourClass');</li>
</ul>
<h4>Create your own Exception handler with
<code>Exception.handler</code></h4>
<p>This gives you full control over the exception handling process.
The class you choose should be loaded in your
app/config/bootstrap.php, so its available to handle any
exceptions. You can define the handler as any callback type. You
can't combine this with other Exception settings.</p>
<pre>
<code>// in app/config/core.php
Configure::write('Exception.handler', 'AppException::handleException');

// in app/config/bootstrap.php
App::import('Lib', 'AppException');

// in app/libs/app_exception.php
&lt;?php
class AppException {
    public static function handleException($error) {
        echo 'Oh noes! ' . $error-&gt;getMessage();
    }
}</code>
</pre>
<p>You can run any code you wish inside handleException. The code
above would simple print 'Oh noes! ' plus the exception message.
You can define exception handlers as any type of callback, even an
anonymous function if you are using PHP 5.3.</p>
<pre>
<code>Configure::write('Exception.handler', function ($error) {
    echo 'Ruh roh ' . $error-&gt;getMessage();
});</code>
</pre>
<h4>Using <code>AppController::appError();</code></h4>
<p>This controller method is called instead of the default
exception rendering. It receives the thrown exception as its only
argument. You should implement your error handling in that
method.</p>
<h4>Using a custom renderer with <code>Exception.renderer</code> to
handle application exceptions</h4>
<p>If you don't want to take control of the exception handling, but
want to change how exceptions are rendered you can use
<code>Configure::write('Exception.renderer',
'AppExceptionRenderer');</code> to choose a class to render
exception pages. By default <code>ExceptionRenderer</code> is used.
Your custom exception renderer class should be placed in app/libs.
In a custom exception rendering class you can provide specialized
handling for application specific errors.</p>
<pre>
<code>// in app/libs/app_exception_renderer.php
&lt;?php
App::import('Core', 'ExceptionRenderer');

class AppExceptionRenderer extends ExceptionRenderer {
    public function missingWidget($error) {
        echo 'Oops that widget is missing!';
    }
}
?&gt;</code>
</pre>
<p>The above would handle any exceptions of the type
<code>MissingWidgetException</code>, and allow you to provide
custom display/handling logic for those application exceptions.
Exception handling methods get the exception being handled as their
argument.</p>
<p>Your custom renderer should expect an exception in its
constructor, and implement a render method. Failing to do so will
cause additional errors.</p>
<h4>Creating a custom controller to handle exceptions</h4>
<p>In your ExceptionRenderer sub-class, you can use the
<code>_getController</code> method to allow you to return a custom
controller to handle your errors. By default CakePHP uses
<code>CakeErrorController</code> which omits a few of the normal
callbacks to help ensure errors always display. However, you may
need a more custom error handling controller in your application.
By implementing <code>_getController</code> in your
<code>AppError</code> class, you can use any controller you
want.</p>
<pre>
<code>class AppExceptionRenderer extends ExceptionRenderer {
    protected function _getController($exception) {
        App::import('Controller', 'SuperCustomError');
        return new SuperCustomErrorController();
    }
}</code>
</pre>
<p>Alternatively, you could just override the core
CakeErrorController, by including one in
<code>app/controllers</code>. If you are using a custom controller
for error handling, make sure you do all the setup you need in your
constructor, or the render method. As those are the only methods
that the built-in <code>ErrorHandler</code> class directly
call.</p>
<h4>Logging exceptions</h4>
<p>Using the built-in exception handling, you can log all the
exceptions that are dealt with by ErrorHandler by setting
<code>Exception.log</code> to true in your core.php. Enabling this
will log every exception to CakeLog and the configured loggers.</p>
<h3>Built in Exceptions for CakePHP</h3>
<p>There are several built-in exceptions inside CakePHP, outside of
the internal framework exceptions, there are several exceptions for
HTTP methods</p>
<ul>
<li><code>BadRequestException</code> - Used for doing 400 Bad
Request error.</li>
<li><code>UnauthorizedException</code> - Used for doing a 401 Not
found error.</li>
<li><code>ForbiddenException</code> - Used for doing a 403
Forbidden error.</li>
<li><code>NotFoundException</code> - Used for doing a 404 Not found
error.</li>
<li><code>MethodNotAllowedException</code> - Used for doing a 405
Method Not Allowed error.</li>
<li><code>InternalErrorException</code> - Used for doing a 500
Internal Server Error.</li>
</ul>
<p>You can throw these exceptions from you controllers to indicate
failure states. In addition, the following framework layer
exceptions are available, and will be thrown from a number of
CakePHP core components:</p>
<ul>
<li><code>MissingViewException</code></li>
<li><code>MissingLayoutException</code></li>
<li><code>MissingHelperClassException</code></li>
<li><code>MissingHelperFileException</code></li>
<li><code>MissingBehaviorClassException</code></li>
<li><code>MissingBehaviorFileException</code></li>
<li><code>MissingComponentClassException</code></li>
<li><code>MissingComponentFileException</code></li>
<li><code>MissingTaskClassException</code></li>
<li><code>MissingTaskFileException</code></li>
<li><code>MissingShellClassException</code></li>
<li><code>MissingShellFileException</code></li>
<li><code>MissingShellMethodException</code></li>
<li><code>MissingDatabaseException</code></li>
<li><code>MissingConnectionException</code></li>
<li><code>MissingTableException</code></li>
<li><code>MissingActionException</code></li>
<li><code>MissingControllerException</code></li>
<li><code>PrivateActionException</code></li>
</ul>
<p>These exception classes all extend <code>CakeException</code>.
By extending CakeException, you can create your own 'framework'
errors. All of the standard Exceptions that CakePHP will throw also
extend CakeException.</p>
<h3>Using HTTP exceptions in your controllers</h3>
<p>You can throw any of the HTTP related exceptions from your
controller actions to indicate failure states. For example:</p>
<pre>
<code>function view($id) {
    $post = $this-&gt;Post-&gt;read(null, $id);
    if (!$post) {
        throw new NotFoundException();
    }
    $this-&gt;set(compact('post'));
}</code>
</pre>
<p>The above would cause the configured
<code>Exception.handler</code> to catch and process the
NotFoundException. By default this will create an error page, and
log the exception.</p>